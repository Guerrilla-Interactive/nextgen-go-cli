package history

import (
	"fmt"
	"sort"
	"strings"
	"time"

	sharedScreens "github.com/Guerrilla-Interactive/nextgen-go-cli/app/screens/shared"

	"path/filepath"

	"github.com/Guerrilla-Interactive/nextgen-go-cli/app"
	"github.com/Guerrilla-Interactive/nextgen-go-cli/app/commands"
	"github.com/Guerrilla-Interactive/nextgen-go-cli/app/project"
	"github.com/Guerrilla-Interactive/nextgen-go-cli/app/utils"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// truncateWithEllipsis limits s to max runes and appends ‚Ä¶ if truncated.
func truncateWithEllipsis(s string, max int) string {
	r := []rune(s)
	if max <= 0 {
		return ""
	}
	if len(r) <= max {
		return s
	}
	if max <= 1 {
		return "‚Ä¶"
	}
	return string(r[:max-1]) + "‚Ä¶"
}

// filterHistoryWithGeneratedFiles returns only history entries that generated files.
func filterHistoryWithGeneratedFiles(history []project.HistoricCommand) []project.HistoricCommand {
	filtered := []project.HistoricCommand{}
	for _, h := range history {
		if len(h.GeneratedFiles) > 0 {
			filtered = append(filtered, h)
		}
	}
	return filtered
}

// getFilteredSortedHistory returns filtered history sorted newest-first by timestamp.
func getFilteredSortedHistory(history []project.HistoricCommand) []project.HistoricCommand {
	filtered := filterHistoryWithGeneratedFiles(history)
	sort.Slice(filtered, func(i, j int) bool {
		return filtered[i].Timestamp > filtered[j].Timestamp
	})
	return filtered
}

// formatRelativeShort returns a short relative time string (without "ago").
func formatRelativeShort(ts int64) string {
	if ts == 0 {
		return "now"
	}
	d := time.Since(time.Unix(ts, 0))
	if d < 0 {
		d = -d
	}
	if d < time.Minute {
		s := int(d.Seconds())
		if s <= 0 {
			return "now"
		}
		if s == 1 {
			return "1 sec"
		}
		return fmt.Sprintf("%d sec", s)
	}
	if d < time.Hour {
		m := int(d.Minutes())
		if m == 1 {
			return "1 min"
		}
		return fmt.Sprintf("%d min", m)
	}
	if d < 24*time.Hour {
		h := int(d.Hours())
		if h == 1 {
			return "1 hour"
		}
		return fmt.Sprintf("%d hours", h)
	}
	if d < 30*24*time.Hour {
		days := int(d.Hours() / 24)
		if days == 1 {
			return "1 day"
		}
		return fmt.Sprintf("%d days", days)
	}
	if d < 365*24*time.Hour {
		months := int(d.Hours() / (24 * 30))
		if months <= 1 {
			return "1 month"
		}
		return fmt.Sprintf("%d months", months)
	}
	years := int(d.Hours() / (24 * 365))
	if years <= 1 {
		return "1 year"
	}
	return fmt.Sprintf("%d years", years)
}

// updateHistoryPreview generates the file tree preview for the selected history item.
func updateHistoryPreview(m app.Model, registry *project.ProjectRegistry) app.Model {
	m.HistoryFileTreePreview = "Loading preview..."
	if registry == nil || m.ProjectPath == "" {
		m.HistoryFileTreePreview = "(Registry/Project unavailable)"
		return m
	}

	if projectInfo, found := registry.GetProject(m.ProjectPath); found {
		history := getFilteredSortedHistory(projectInfo.CommandHistory)
		totalCmds := len(history)
		if totalCmds == 0 {
			m.HistoryFileTreePreview = "(No command history)"
			return m
		}

		// Use paginator to find the real index
		p := m.HistoryPaginator // Use the correct paginator
		start, _ := p.GetSliceBounds(totalCmds)
		numItemsOnPage := p.ItemsOnPage(totalCmds)
		isBackSelected := m.HistoryScreenIndex == numItemsOnPage // Index relative to page items + Back
		realIndex := start + m.HistoryScreenIndex

		// Check if index is valid (might be on "Back" or out of bounds)
		if isBackSelected || realIndex < 0 || realIndex >= totalCmds {
			m.HistoryFileTreePreview = "(Select a command)"
			return m
		}

		// Get the specific command record from history
		historicCmd := history[realIndex]
		generatedFiles := historicCmd.GeneratedFiles // <-- Get the stored file list

		// --- Generate file tree directly from stored GeneratedFiles ---
		if len(generatedFiles) > 0 {
			// Build the file tree using the shared utils package.
			// Note: generatedFiles should ideally store relative paths already.
			treeRoot := utils.BuildFileTree(generatedFiles)
			m.HistoryFileTreePreview = utils.RenderFileTree(treeRoot, "", true, false, func(path string) bool {
				// Check if the file at path is in the EditedIndexers map (less relevant here, but keep for consistency)
				// We might need a better way to track edits historically if needed.
				if edited, ok := commands.EditedIndexers[filepath.Join(m.ProjectPath, path)]; ok && edited { // Check absolute path?
					return true
				}
				return false
			})
		} else {
			// If no files were generated by this command
			m.HistoryFileTreePreview = fmt.Sprintf("(No files were generated by command: %s)", historicCmd.Name)
		}
		// --- End preview generation ---

	} else {
		m.HistoryFileTreePreview = "(Project not found)"
	}
	return m
}

// UpdateScreenCommandHistory handles input on the Command History screen.
func UpdateScreenCommandHistory(m app.Model, msg tea.KeyMsg, registry *project.ProjectRegistry) (app.Model, tea.Cmd) {
	var history []project.HistoricCommand
	if projectInfo, found := registry.GetProject(m.ProjectPath); found {
		history = getFilteredSortedHistory(projectInfo.CommandHistory)
	}
	totalCmds := len(history)

	// --- Paginator Setup ---
	m.HistoryPaginator.SetTotalPages(totalCmds)
	p := &m.HistoryPaginator

	// --- Calculate index and page options ---
	start, end := p.GetSliceBounds(totalCmds)
	numItemsOnPage := end - start
	numOptionsOnPage := numItemsOnPage + 1 // Items + Back
	if m.HistoryScreenIndex >= numOptionsOnPage {
		m.HistoryScreenIndex = numOptionsOnPage - 1
	}
	if m.HistoryScreenIndex < 0 {
		m.HistoryScreenIndex = 0
	}
	isBackSelected := m.HistoryScreenIndex == numItemsOnPage

	// Update paginator first
	var paginatorCmd tea.Cmd
	*p, paginatorCmd = p.Update(msg)

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "left", "h":
		if totalCmds > 0 { // Only paginate if list not empty
			*p, paginatorCmd = p.Update(tea.KeyMsg{Type: tea.KeyLeft})
			m.HistoryScreenIndex = 0              // Reset index to top of new page
			m = updateHistoryPreview(m, registry) // Update preview for new page
		}
		return m, paginatorCmd

	case "right", "l":
		if totalCmds > 0 { // Only paginate if list not empty
			*p, paginatorCmd = p.Update(tea.KeyMsg{Type: tea.KeyRight})
			m.HistoryScreenIndex = 0              // Reset index to top of new page
			m = updateHistoryPreview(m, registry) // Update preview for new page
		}
		return m, paginatorCmd

	case "up", "k":
		if numOptionsOnPage > 0 { // Avoid modulo by zero
			newIndex := (m.HistoryScreenIndex + numOptionsOnPage - 1) % numOptionsOnPage
			if newIndex != m.HistoryScreenIndex {
				m.HistoryScreenIndex = newIndex
				m = updateHistoryPreview(m, registry)
			}
		}

	case "down", "j":
		if numOptionsOnPage > 0 { // Avoid modulo by zero
			newIndex := (m.HistoryScreenIndex + 1) % numOptionsOnPage
			if newIndex != m.HistoryScreenIndex {
				m.HistoryScreenIndex = newIndex
				m = updateHistoryPreview(m, registry)
			}
		}

	case "enter":
		if isBackSelected {
			m.CurrentScreen = app.ScreenMain
			m.HistoryScreenIndex = 0
			m.HistoryFileTreePreview = ""
			return m, nil
		}
		// Enter on a history item: rerun the same command via shared selection logic
		if totalCmds > 0 {
			// Compute real index within filtered history list
			realIndex := start + m.HistoryScreenIndex
			if realIndex >= 0 && realIndex < totalCmds {
				itemName := history[realIndex].Name
				var selectCmd tea.Cmd
				var updatedModel *app.Model
				updatedModel, selectCmd = sharedScreens.HandleCommandSelection(&m, registry, itemName)
				m = *updatedModel
				m.CurrentPreviewType = "none"
				m.HistoryFileTreePreview = ""
				return m, tea.Batch(paginatorCmd, selectCmd)
			}
		}

	case "esc", "b": // Go back to Recent Commands
		m.CurrentScreen = app.ScreenMain
		m.HistoryScreenIndex = 0
		m.HistoryFileTreePreview = ""
		return m, nil
	}

	return m, paginatorCmd // Return model and any cmd from paginator
}

// ViewScreenCommandHistory renders the command history screen.
func ViewScreenCommandHistory(m app.Model, registry *project.ProjectRegistry) string {
	header := app.TitleStyle.Render("Project Command History") + "\n"

	// --- Get Data ---
	var history []project.HistoricCommand
	var projectFound bool
	if registry != nil && m.ProjectPath != "" {
		if projectInfo, found := registry.GetProject(m.ProjectPath); found {
			history = getFilteredSortedHistory(projectInfo.CommandHistory)
			projectFound = true
		}
	}
	totalCmds := len(history)
	p := m.HistoryPaginator // Use the correct paginator
	start, end := p.GetSliceBounds(totalCmds)
	paginatedCmds := []project.HistoricCommand{}
	if start < end {
		paginatedCmds = history[start:end]
	}
	numItemsOnPage := len(paginatedCmds)
	isBackSelected := m.HistoryScreenIndex == numItemsOnPage

	// --- Calculate Paginator View Early ---
	paginatorView := ""
	if totalCmds > p.PerPage {
		p.SetTotalPages(totalCmds) // Ensure total pages is set
		paginatorView = p.View()
	}

	// --- Left Pane: History List ---
	var leftBuilder strings.Builder

	if !projectFound {
		leftBuilder.WriteString(app.ChoiceStyle.Render("  (Project history not available)"))
	} else if totalCmds == 0 {
		leftBuilder.WriteString(app.ChoiceStyle.Render("  (No commands recorded yet)"))
	} else {
		// Display paginated commands with relative time prefix
		for i, historicCmd := range paginatedCmds {
			// Format relative time and style it subtly
			rel := formatRelativeShort(historicCmd.Timestamp)
			timePrefix := lipgloss.NewStyle().Foreground(lipgloss.Color("#888")).Render(rel)
			label := truncateWithEllipsis(historicCmd.Name, 42)
			line := timePrefix + "  " + label
			if i == m.HistoryScreenIndex { // Check against index on page
				leftBuilder.WriteString(app.HighlightStyle.Render(line) + "\n")
			} else {
				leftBuilder.WriteString(app.ChoiceStyle.Render(line) + "\n")
			}
		}
	}

	// Spacer and paginator
	leftBuilder.WriteString("\n")
	if paginatorView != "" {
		leftBuilder.WriteString(paginatorView + "\n")
	}
	// Back option
	if isBackSelected {
		leftBuilder.WriteString(app.HighlightStyle.Render("Back") + "\n")
	} else {
		leftBuilder.WriteString(app.ChoiceStyle.Render("Back") + "\n")
	}

	// --- Define Layout similar to Recent screen (no borders, bottom-aligned) ---
	leftPanelWidth := 50
	leftPanelStyle := lipgloss.NewStyle().Padding(0, 1)

	// Footer (help only)
	footer := sharedScreens.Footer("‚Üë‚Üì ‚Üê‚Üí navigate", "ctrl+c quit")
	footerHeight := lipgloss.Height(footer)
	availableHeightForPanes := m.TerminalHeight - footerHeight - 1
	if availableHeightForPanes < 10 {
		availableHeightForPanes = 10
	}

	// Right Pane: Preview
	previewContent := m.HistoryFileTreePreview
	if previewContent == "" {
		previewContent = app.HelpStyle.Render("Select a command to see its generated file tree.")
	}

	// Truncate raw preview content BEFORE adding header/styling
	folderHeaderHeight := 2 // "üì¶ folderName\n\n"
	previewPadding := 2     // Top/bottom padding of 1 each
	maxPreviewContentHeight := availableHeightForPanes - folderHeaderHeight - previewPadding
	if maxPreviewContentHeight < 1 {
		maxPreviewContentHeight = 1
	}
	lines := strings.Split(previewContent, "\n")
	if len(lines) > maxPreviewContentHeight {
		previewContent = strings.Join(lines[:maxPreviewContentHeight], "\n")
	}

	// Prepend folder header
	folderName := filepath.Base(m.ProjectPath)
	previewHeader := lipgloss.NewStyle().Foreground(lipgloss.Color("#888")).Render(fmt.Sprintf("üì¶ %s", folderName))
	previewContentWithHeader := previewHeader + "\n\n" + previewContent

	// Build right panel and bottom-align
	rightInner := lipgloss.NewStyle().Padding(1, 1).Render(previewContentWithHeader)
	rightPanel := lipgloss.Place(lipgloss.Width(rightInner), availableHeightForPanes, lipgloss.Left, lipgloss.Bottom, rightInner)

	// Render left panel content and bottom-align
	leftContentCombined := lipgloss.JoinVertical(lipgloss.Left, header, leftBuilder.String())
	leftRendered := leftPanelStyle.Render(leftContentCombined)
	leftPanel := lipgloss.Place(leftPanelWidth, availableHeightForPanes, lipgloss.Left, lipgloss.Bottom, leftRendered)

	// Combine panes and footer
	combinedPanes := lipgloss.JoinHorizontal(lipgloss.Top, leftPanel, " ", rightPanel)
	finalLayout := lipgloss.JoinVertical(lipgloss.Left, combinedPanes, "\n", footer)
	if m.TerminalWidth > 0 && m.TerminalHeight > 0 {
		return lipgloss.Place(m.TerminalWidth, m.TerminalHeight, lipgloss.Left, lipgloss.Bottom, finalLayout)
	}
	return finalLayout
}
