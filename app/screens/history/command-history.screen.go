package history

import (
	"fmt"
	"strings"

	"path/filepath"

	"github.com/Guerrilla-Interactive/nextgen-go-cli/app"
	"github.com/Guerrilla-Interactive/nextgen-go-cli/app/commands"
	"github.com/Guerrilla-Interactive/nextgen-go-cli/app/project"
	"github.com/Guerrilla-Interactive/nextgen-go-cli/app/utils"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// updateHistoryPreview generates the file tree preview for the selected history item.
func updateHistoryPreview(m app.Model, registry *project.ProjectRegistry) app.Model {
	m.HistoryFileTreePreview = "Loading preview..."
	if registry == nil || m.ProjectPath == "" {
		m.HistoryFileTreePreview = "(Registry/Project unavailable)"
		return m
	}

	if projectInfo, found := registry.GetProject(m.ProjectPath); found {
		history := projectInfo.CommandHistory
		totalCmds := len(history)
		if totalCmds == 0 {
			m.HistoryFileTreePreview = "(No command history)"
			return m
		}

		// Use paginator to find the real index
		p := m.HistoryPaginator // Use the correct paginator
		start, _ := p.GetSliceBounds(totalCmds)
		numItemsOnPage := p.ItemsOnPage(totalCmds)
		isBackSelected := m.HistoryScreenIndex == numItemsOnPage // Index relative to page items + Back
		realIndex := start + m.HistoryScreenIndex

		// Check if index is valid (might be on "Back" or out of bounds)
		if isBackSelected || realIndex < 0 || realIndex >= totalCmds {
			m.HistoryFileTreePreview = "(Select a command)"
			return m
		}

		// Get the specific command record from history
		historicCmd := history[realIndex]
		generatedFiles := historicCmd.GeneratedFiles // <-- Get the stored file list

		// --- Generate file tree directly from stored GeneratedFiles ---
		if len(generatedFiles) > 0 {
			// Build the file tree using the shared utils package.
			// Note: generatedFiles should ideally store relative paths already.
			treeRoot := utils.BuildFileTree(generatedFiles)
			m.HistoryFileTreePreview = utils.RenderFileTree(treeRoot, "", true, false, func(path string) bool {
				// Check if the file at path is in the EditedIndexers map (less relevant here, but keep for consistency)
				// We might need a better way to track edits historically if needed.
				if edited, ok := commands.EditedIndexers[filepath.Join(m.ProjectPath, path)]; ok && edited { // Check absolute path?
					return true
				}
				return false
			})
		} else {
			// If no files were generated by this command
			m.HistoryFileTreePreview = fmt.Sprintf("(No files were generated by command: %s)", historicCmd.Name)
		}
		// --- End preview generation ---

	} else {
		m.HistoryFileTreePreview = "(Project not found)"
	}
	return m
}

// UpdateScreenCommandHistory handles input on the Command History screen.
func UpdateScreenCommandHistory(m app.Model, msg tea.KeyMsg, registry *project.ProjectRegistry) (app.Model, tea.Cmd) {
	var history []project.HistoricCommand
	if projectInfo, found := registry.GetProject(m.ProjectPath); found {
		history = projectInfo.CommandHistory
	}
	totalCmds := len(history)

	// --- Paginator Setup ---
	m.HistoryPaginator.SetTotalPages(totalCmds)
	p := &m.HistoryPaginator

	// --- Calculate index and page options ---
	start, end := p.GetSliceBounds(totalCmds)
	numItemsOnPage := end - start
	numOptionsOnPage := numItemsOnPage + 1 // Items + Back
	if m.HistoryScreenIndex >= numOptionsOnPage {
		m.HistoryScreenIndex = numOptionsOnPage - 1
	}
	if m.HistoryScreenIndex < 0 {
		m.HistoryScreenIndex = 0
	}
	isBackSelected := m.HistoryScreenIndex == numItemsOnPage

	// Update paginator first
	var paginatorCmd tea.Cmd
	*p, paginatorCmd = p.Update(msg)

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "left", "h":
		if totalCmds > 0 { // Only paginate if list not empty
			*p, paginatorCmd = p.Update(tea.KeyMsg{Type: tea.KeyLeft})
			m.HistoryScreenIndex = 0              // Reset index to top of new page
			m = updateHistoryPreview(m, registry) // Update preview for new page
		}
		return m, paginatorCmd

	case "right", "l":
		if totalCmds > 0 { // Only paginate if list not empty
			*p, paginatorCmd = p.Update(tea.KeyMsg{Type: tea.KeyRight})
			m.HistoryScreenIndex = 0              // Reset index to top of new page
			m = updateHistoryPreview(m, registry) // Update preview for new page
		}
		return m, paginatorCmd

	case "up", "k":
		if numOptionsOnPage > 0 { // Avoid modulo by zero
			newIndex := (m.HistoryScreenIndex + numOptionsOnPage - 1) % numOptionsOnPage
			if newIndex != m.HistoryScreenIndex {
				m.HistoryScreenIndex = newIndex
				m = updateHistoryPreview(m, registry)
			}
		}

	case "down", "j":
		if numOptionsOnPage > 0 { // Avoid modulo by zero
			newIndex := (m.HistoryScreenIndex + 1) % numOptionsOnPage
			if newIndex != m.HistoryScreenIndex {
				m.HistoryScreenIndex = newIndex
				m = updateHistoryPreview(m, registry)
			}
		}

	case "enter":
		if isBackSelected {
			m.CurrentScreen = app.ScreenSettings
			m.HistoryScreenIndex = 0
			m.HistoryFileTreePreview = ""
			return m, nil
		}
		// Enter on history items still does nothing

	case "esc", "b": // Go back to Settings
		m.CurrentScreen = app.ScreenSettings
		m.HistoryScreenIndex = 0
		m.HistoryFileTreePreview = ""
		return m, nil
	}

	return m, paginatorCmd // Return model and any cmd from paginator
}

// ViewScreenCommandHistory renders the command history screen.
func ViewScreenCommandHistory(m app.Model, registry *project.ProjectRegistry) string {
	header := app.TitleStyle.Render("Project Command History") + "\n"

	// --- Get Data ---
	var history []project.HistoricCommand
	var projectFound bool
	if registry != nil && m.ProjectPath != "" {
		if projectInfo, found := registry.GetProject(m.ProjectPath); found {
			history = projectInfo.CommandHistory
			projectFound = true
		}
	}
	totalCmds := len(history)
	p := m.HistoryPaginator // Use the correct paginator
	start, end := p.GetSliceBounds(totalCmds)
	paginatedCmds := []project.HistoricCommand{}
	if start < end {
		paginatedCmds = history[start:end]
	}
	numItemsOnPage := len(paginatedCmds)
	isBackSelected := m.HistoryScreenIndex == numItemsOnPage

	// --- Calculate Paginator View Early ---
	paginatorView := ""
	if totalCmds > p.PerPage {
		p.SetTotalPages(totalCmds) // Ensure total pages is set
		paginatorView = p.View()
	}

	// --- Left Pane: History List ---
	var leftBuilder strings.Builder
	leftBuilder.WriteString(app.SubtitleStyle.Render("Commands Run") + "\n\n")

	if !projectFound {
		leftBuilder.WriteString(app.ChoiceStyle.Render("  (Project history not available)"))
	} else if totalCmds == 0 {
		leftBuilder.WriteString(app.ChoiceStyle.Render("  (No commands recorded yet)"))
	} else {
		// Display paginated commands
		for i, historicCmd := range paginatedCmds {
			cmdName := historicCmd.Name
			if i == m.HistoryScreenIndex { // Check against index on page
				leftBuilder.WriteString(app.HighlightStyle.Render("> "+cmdName) + "\n")
			} else {
				leftBuilder.WriteString(app.ChoiceStyle.Render("  "+cmdName) + "\n")
			}
		}
	}

	// --- Append Paginator and Back Button to Left Pane ---
	leftBuilder.WriteString("\n") // Spacer
	if paginatorView != "" {
		// Remove MarginTop, just add the view and a newline
		leftBuilder.WriteString(paginatorView + "\n")
	}
	if isBackSelected { // Highlight based on index on page
		leftBuilder.WriteString(app.HighlightStyle.Render("> Back") + "\n")
	} else {
		leftBuilder.WriteString(app.ChoiceStyle.Render("  Back") + "\n")
	}

	leftPanelWidth := 40 // Define fixed width for left panel
	leftPanelStyle := lipgloss.NewStyle().
		Width(leftPanelWidth). // Apply fixed width
		Padding(1, 2).
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("62"))
	leftPanel := leftPanelStyle.Render(leftBuilder.String())

	// --- Right Pane: File Tree Preview ---
	previewContent := m.HistoryFileTreePreview
	if previewContent == "" {
		previewContent = app.HelpStyle.Render("Select a command to see its generated file tree.")
	}

	// --- Truncate Preview Content ---
	const maxPreviewLines = 12
	lines := strings.Split(previewContent, "\n")
	if len(lines) > maxPreviewLines {
		previewContent = strings.Join(lines[:maxPreviewLines], "\n")
		previewContent += "\n... (truncated)"
	}

	// Prepend header
	folderName := filepath.Base(m.ProjectPath)
	headerPreview := lipgloss.NewStyle().Foreground(lipgloss.Color("#888")).Render(fmt.Sprintf("📦 %s", folderName))
	previewContent = headerPreview + "\n\n" + previewContent // Use the potentially truncated content

	// Define right panel style WITHOUT explicit width
	rightPanelStyle := lipgloss.NewStyle().
		Padding(1, 2).
		Height(lipgloss.Height(leftPanel)). // Match height roughly
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("62"))
	rightPanel := rightPanelStyle.Render(previewContent)

	// --- Combine & Footer ---
	combinedPanes := lipgloss.JoinHorizontal(lipgloss.Top, leftPanel, "  ", rightPanel)

	// Paginator View is now part of the left pane, remove from final join
	footer := app.HelpStyle.Render("Use ↑/↓/←/→ to navigate, Esc/b to go back.")
	finalView := lipgloss.JoinVertical(lipgloss.Left, header, combinedPanes, "\n", footer) // REMOVED paginatorView here
	if m.TerminalWidth > 0 && m.TerminalHeight > 0 {
		return lipgloss.Place(m.TerminalWidth, m.TerminalHeight, lipgloss.Left, lipgloss.Bottom, finalView)
	}
	return finalView
}
