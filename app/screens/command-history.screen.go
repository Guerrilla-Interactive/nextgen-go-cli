package screens

import (
	"fmt"
	"strings"

	"path/filepath"

	"github.com/Guerrilla-Interactive/nextgen-go-cli/app"
	"github.com/Guerrilla-Interactive/nextgen-go-cli/app/commands"
	"github.com/Guerrilla-Interactive/nextgen-go-cli/app/project"
	"github.com/Guerrilla-Interactive/nextgen-go-cli/app/utils"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// updateHistoryPreview generates the file tree preview for the selected history item.
func updateHistoryPreview(m app.Model, registry *project.ProjectRegistry) app.Model {
	m.HistoryFileTreePreview = "Loading preview..."
	if registry == nil || m.ProjectPath == "" {
		m.HistoryFileTreePreview = "(Registry/Project unavailable)"
		return m
	}

	if projectInfo, found := registry.GetProject(m.ProjectPath); found {
		history := projectInfo.CommandHistory
		if len(history) == 0 {
			m.HistoryFileTreePreview = "(No command history)"
			return m
		}
		// Check if index is valid (might be on "Back")
		if m.HistoryScreenIndex < 0 || m.HistoryScreenIndex >= len(history) {
			m.HistoryFileTreePreview = "(Select a command)"
			return m
		}

		// Get the specific command record from history
		historicCmd := history[m.HistoryScreenIndex]
		generatedFiles := historicCmd.GeneratedFiles // <-- Get the stored file list

		// --- Generate file tree directly from stored GeneratedFiles ---
		if len(generatedFiles) > 0 {
			// Build the file tree using the shared utils package.
			// Note: generatedFiles should ideally store relative paths already.
			treeRoot := utils.BuildFileTree(generatedFiles)
			m.HistoryFileTreePreview = utils.RenderFileTree(treeRoot, "", true, false, func(path string) bool {
				// Check if the file at path is in the EditedIndexers map (less relevant here, but keep for consistency)
				// We might need a better way to track edits historically if needed.
				if edited, ok := commands.EditedIndexers[filepath.Join(m.ProjectPath, path)]; ok && edited { // Check absolute path?
					return true
				}
				return false
			})
		} else {
			// If no files were generated by this command
			m.HistoryFileTreePreview = fmt.Sprintf("(No files were generated by command: %s)", historicCmd.Name)
		}
		// --- End preview generation ---

	} else {
		m.HistoryFileTreePreview = "(Project not found)"
	}
	return m
}

// UpdateScreenCommandHistory handles input on the Command History screen.
func UpdateScreenCommandHistory(m app.Model, msg tea.KeyMsg, registry *project.ProjectRegistry) (app.Model, tea.Cmd) {
	var historyLen int
	if projectInfo, found := registry.GetProject(m.ProjectPath); found {
		historyLen = len(projectInfo.CommandHistory)
	}
	numOptions := historyLen + 1 // Commands + Back

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "up", "k":
		newIndex := (m.HistoryScreenIndex + numOptions - 1) % numOptions
		if newIndex != m.HistoryScreenIndex {
			m.HistoryScreenIndex = newIndex
			// Update preview when selection changes
			m = updateHistoryPreview(m, registry)
		}

	case "down", "j":
		newIndex := (m.HistoryScreenIndex + 1) % numOptions
		if newIndex != m.HistoryScreenIndex {
			m.HistoryScreenIndex = newIndex
			// Update preview when selection changes
			m = updateHistoryPreview(m, registry)
		}

	case "enter":
		// If "Back" is selected (index == historyLen), go back to Settings
		if m.HistoryScreenIndex == historyLen {
			m.CurrentScreen = app.ScreenSettings
			// Reset index for next time
			m.HistoryScreenIndex = 0
			m.HistoryFileTreePreview = ""
			return m, nil
		}
		// Enter on history items currently does nothing

	case "esc", "b": // Go back to Settings
		m.CurrentScreen = app.ScreenSettings
		// Reset index for next time
		m.HistoryScreenIndex = 0
		m.HistoryFileTreePreview = ""
		return m, nil
	}

	return m, nil
}

// ViewScreenCommandHistory renders the command history screen.
func ViewScreenCommandHistory(m app.Model, registry *project.ProjectRegistry) string {
	header := app.TitleStyle.Render("Project Command History") + "\n"

	// --- Left Pane: History List ---
	var leftBuilder strings.Builder
	leftBuilder.WriteString(app.SubtitleStyle.Render("Commands Run") + "\n\n")

	// Change history type to match ProjectInfo
	var history []project.HistoricCommand
	var projectFound bool
	if registry != nil && m.ProjectPath != "" {
		if projectInfo, found := registry.GetProject(m.ProjectPath); found {
			history = projectInfo.CommandHistory // Direct assignment is now fine
			projectFound = true
		}
	}

	if !projectFound {
		leftBuilder.WriteString(app.ChoiceStyle.Render("  (Project history not available)"))
	} else if len(history) == 0 {
		leftBuilder.WriteString(app.ChoiceStyle.Render("  (No commands recorded yet)"))
	} else {
		// Display commands (newest first maybe? currently oldest first)
		for i, historicCmd := range history {
			// Access the Name field for display
			cmdName := historicCmd.Name
			if i == m.HistoryScreenIndex {
				leftBuilder.WriteString(app.HighlightStyle.Render("> "+cmdName) + "\n")
			} else {
				leftBuilder.WriteString(app.ChoiceStyle.Render("  "+cmdName) + "\n")
			}
		}
	}
	leftBuilder.WriteString("\n") // Spacer

	// Add Back button
	if m.HistoryScreenIndex == len(history) { // Back is selected
		leftBuilder.WriteString(app.HighlightStyle.Render("> Back") + "\n")
	} else {
		leftBuilder.WriteString(app.ChoiceStyle.Render("  Back") + "\n")
	}

	leftPanelStyle := lipgloss.NewStyle().
		Width(40). // Adjust width as needed
		Padding(1, 2).
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("62"))
	leftPanel := leftPanelStyle.Render(leftBuilder.String())

	// --- Right Pane: File Tree Preview ---
	previewContent := m.HistoryFileTreePreview
	if previewContent == "" {
		// Initial state or when Back is selected
		previewContent = app.HelpStyle.Render("Select a command from the history to see its generated file preview.")
	}

	rightPanel := lipgloss.NewStyle().
		Padding(1, 2).
		Width(m.TerminalWidth - 40 - 8).
		Height(lipgloss.Height(leftPanel)).
		Render(previewContent)

	// --- Combine ---
	combinedPanes := lipgloss.JoinHorizontal(lipgloss.Top, leftPanel, "  ", rightPanel)

	// --- Footer ---
	footer := app.HelpStyle.Render("Use ↑/↓ to navigate, Enter on Back (or Esc/b) to return.")

	return lipgloss.JoinVertical(lipgloss.Left, header, combinedPanes, "\n", footer)
}
